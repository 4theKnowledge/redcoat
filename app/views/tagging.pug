extends layout

//- block sidenav
//- 	nav#sidenav.sidenav-project.hotkeys
//- 		h3 Hotkeys
//- 		ul
//- 			li <b>Q:</b> Tagging window
				


block content
	div#tagging-container
		#sentence-tagging


block entity_categories_window

	div#tagging-menu
		div.category-hierarchy
			div.tokens-info
				p.tokens 
				p.summary 
				span.more 
					span.left Results from Wikipedia
					span.right <a href="#" id="ec-read-more" target="_blank">Read more <i class="fa fa-sm fa-external-link"></i></a>
			div.label-search
				input(placeholder="Search categories..." autofocus id="ec-search")
			div#category-hierarchy-tree
			div#category-hierarchy-tree-no-results
				| No results found.

	div#entity-categories-window.tagging
		div.inner
			div.category-tree
				h3 Category Hierarchy
				svg#svg-entity-categories
				div#category-hierarchy-error
					div.message Loading concept hierarchy...
			a.close <span>Close (ESC)</span>&nbsp;<i class="fa fa-close"></i>
	div#window-mask

block scripts
	script(src="/javascripts/jstree/dist/jstree.js")
	script(src="/javascripts/d3/d3.min.js")
	script(src="/javascripts/d3/d3-context-menu.js")
	script(src="/javascripts/shared/hierarchy_validator.js")
	script(src="/javascripts/category-tree-visualisation.js")

	script.

		// Construct the JSTree from the category hierarchy data.
		function buildJsTree(hierarchy) {


			var $tree = $("#category-hierarchy-tree");
			var $ecSearch = $("#ec-search");
			var $noSearchResults = $("#category-hierarchy-tree-no-results")

			for(var j in hierarchy) {
				console.log(j, hierarchy[j]);

			}
			console.log("---------")

			$tree.jstree(
				{ 
				"plugins" : [ "search" ],//, "sort" ],
				"search": {
					show_only_matches: true,
				},
				'core' : {
				    'data' : slash2json(hierarchy, 'text'),
				    'dblclick_toggle' : false,

				},
				//- 'sort' : function(a, b) {
				//- 	a1 = this.get_node(a);
				//- 	b1 = this.get_node(b);
				//- 	return (a1.text > b1.text) ? 1 : -1;			        
				//- }
			});

			//- var dblClickTimeout = null;

			$tree.on('click', '.jstree-anchor', function (e) {		
				//- if(!dblClickTimeout) {
					//- dblClickTimeout = setTimeout( function() {
				$tree.jstree(true).toggle_node(e.target);
				console.log($tree.jstree('get_selected', true)[0].text);
						//- dblClickTimeout = null;
					//- }, 100);
				//- }
			});

			//- $tree.bind("dblclick.jstree", function (e, data) {
			//- 	var node = $(e.target).closest("li");
			//- 	var id = node[0].id; //id of the selected node
			//- 	clearTimeout(dblClickTimeout);
			//- 	dblClickTimeout = null;
			//- 	e.preventDefault();
			//- });

			$tree.on('search.jstree', function(e, data) {
				if(data.res.length == 0 && $ecSearch.val().length > 0) {
					$noSearchResults.show();
					$tree.hide();
				} else {
					$noSearchResults.hide();
					$tree.show();
				}
			})

			$ecSearch.keyup(function () {
				var v = $ecSearch.val();
				$tree.jstree(true).search(v, { "show_only_matches": true });
				if($ecSearch.val().length == 0) {
					$noSearchResults.hide();
					$tree.show();				
				}
			});

			return $tree;

		}

		function initTagging() {


			var categoryHierarchy = new CategoryHierarchy();



			var groupData = !{data};
			var entity_classes = !{entity_classes};

			categoryHierarchy.buildTree(entity_classes);
			var $tree = buildJsTree(entity_classes);
			//var entity_classes_abbr = !{entity_classes_abbr};

			var $entityCategoriesWindow = $("#entity-categories-window");

			var $taggingMenuTokens = $("#tagging-menu .tokens");
			var $taggingMenuSummary = $("#tagging-menu .summary");
			var $taggingMenuMore = $("#tagging-menu .more");
			var $taggingMenuReadMore = $("#ec-read-more");
			var $taggingMenuSearch = $("#ec-search");
			var $windowMask = $("#window-mask");

			$("#entity-categories-window .close").click(function() {
				$entityCategoriesWindow.removeClass("show");
			});
			$windowMask.click(function() {
				$entityCategoriesWindow.removeClass("show");
			})
			
			var tagClassNames = entity_classes_abbr; // The names of each of the classes.

			var st = $("#sentence-tagging");
			const
			WS = '<span class=\"word\" data-ind="$$$">', // Word start 
			WE = "</span>", 	// Word end
			PS = '<span class=\"punctuation\" data-ind="$$$">', // Punctuation start 
			PE = "</span>"; // Punctuation end

			//var annotatedTagNumbers = [];		// The 'tag numbers' (indexes of the tags).
			var annotatedTags = [];

			var sentenceIndex;					// The index of the sentence currently selected.
			var wordIndex;						// The index of the word currently selected.
			var sentenceLength;					// The length of the sentence currently selected.
			var chaining = false;				// Whether 'chaining' is currently happening (multiple tokens selected at once).
			var chainStart;						// The index that the 'chain' (multiple tokens selected with shift) begins.
			var chainType;						// The type of the chain (can be "forwards" or "backwards").
			var currentlyScrolling = false;		// Whether the browser is currently scrolling to the top.

			var loading = true;					// Whether the tagging interface is loading (can't do anything if it is).
			var ended = false;					// Whether annotation is complete (i.e. the user has no more document groups to annotate).

			var queryWikipediaId = 0;			// A counter to keep track of the index of the current Wikipedia query (to prevent overlapping of results).

			function finishedScrolling() {
				currentlyScrolling = false;
			}


			var entity_classes_abbr = [];
			// Build abbreviated entity class names to display on the annotation labels.
			(function generateAbbreviatedNames() {
				for(var i in entity_classes) {
					var ec = entity_classes[i].toLowerCase();
					ecs = ec.split('/');
					ec = (ecs.length > 1 ? '/' : '') + ecs[ecs.length-1];
					var abbr = ec;
					//var abbr = (ec.match(/[b-df-hj-np-tv-z]*[aeiou]+[b-df-hj-np-tv-z]+/g) || ['(unknown)'])[0];
					entity_classes_abbr.push(abbr);
				}
			})();

			// Generate the legend in the sidenav.
			//- (function generateLegend() {
			//- 	var ll = $("#legend-list");
			//- 	var count = 0;
			//- 	for(var i = 0; i < entity_classes.length; i++) {
			//- 		count++;
			//- 		if(count == 10) {
			//- 			count = 0;
			//- 		}
			//- 		ll.append("<li><b>" + count + ". </b>" + entity_classes[i] + "</li>");
			//- 	}
			//- })();

			// Load a random document group from the project. Initialise the interface.
			function loadGroup() {
				console.log("Loading group...");
				$("#ending-message").remove();
				loading = true;

				// TODO: Replace this with Ajax.
				$("#tagging-container").children(0).fadeOut(300, continueLoading);

				//} else {
				//	$("#tagging-container").children(0).fadeOut(300, showEndingMessage);
				//}

				// Continue the loading process.
				// This function is called only after the sentence tagging ele has faded out.
				function continueLoading() {
					//annotatedTagNumbers = [];	// 
					annotatedTags = [];
					st.remove(); // Clear the sentence tagging div and create a new one.
					$("<div id=\"sentence-tagging\"></div>").hide().appendTo("#tagging-container").fadeIn(300);
					st = $("#sentence-tagging");

					
					// Iterate over the sentences and create the annotatedTagNumbers and annotatedTags arrays.
					var indSent = 0;
					$.each(groupData, function(key, value) {
						var content = "";
						var ind = 0;
						for(var i in value) {
							// If all punctuation, use the punctuation class instead.
							if((value[i].match(/[.,\/#!$%\^&\*;:{}=\-_`~()"']/g) || []).length == value[i].length) {
								content += PS.replace(/\$\$\$/g, ind) + value[i] + PE;
							} else {
								content += WS.replace(/\$\$\$/g, ind) + value[i] + WE;
								
							}	
							ind++;						
						}
						var s = st.append("<div class=\"sentence\" data-ind=\"" + indSent + "\" data-ind1=\"" + (indSent+1) + "\">" + content + "</div>");
						//annotatedTagNumbers.push(new Array(value.length).fill(-1));
						annotatedTags.push(new Array(value.length).fill("O"));
						indSent++;
					});

					sentenceIndex = 0;
					wordIndex = -1;
					sentenceLength = calculateSentenceLength();
					
					chainStart = -1;
					chainType = "forwards";
					st.children(0).eq(sentenceIndex).addClass("selected");
					moveForwards();

					if(currentlyScrolling) {
						$("html, body").scrollTop(st.children().eq(sentenceIndex).offset().top - 150);
					} else {
						currentlyScrolling = true
						$("html, body").animate({
							//scrollTop: st.children().eq(sentenceIndex).offset().top - 150
						}, 200, finishedScrolling);										
					}
					loading = false;
					selectedWord = getSelectedWord();
					selectedWord.addClass("selected");

					initMouseEvents();
				}

				// TODO: Replace this with some kind of thing saying "Congratulations, you've finished annotating every document!" or something along those lines.
				function showEndingMessage() {
					st.remove();
					$("<div id=\"sentence-tagging\"></div>").hide().appendTo("#tagging-container").fadeIn(300);
					st = $("#sentence-tagging");
					$("#tagging-container").append("<div id=\"ending-message\">Well done!</div>")
					//showEndingNotification()
					loading = false;
					ended = true;
				}
			}
			loadGroup();		

			// A shortcut function to find the element corresponding to the selected word.
			function getSelectedWord() {
				return st.children().eq(sentenceIndex).children('span.word').eq(wordIndex);
			}		

			// Calculate the sentence length of the current sentence.
			function calculateSentenceLength() {
				sentenceLength = st.children().eq(sentenceIndex).children('span.word').length		
				return sentenceLength;
			}


			function tagSelected(tagClass, colorIndex, moveAfterwards=true) {

				$("span.word.selected").removeClass(function (index, className) {
					return (className.match (/(^|\s)tag-\S+/g) || []).join(' ');
				});
				if(colorIndex == null) colorIndex = tagClass;
				$("span.word.selected").addClass("tag");
				$("span.word.selected").addClass("tag-" + colorIndex);
				
				$("span.word.selected").attr("data-content", entity_classes_abbr[tagClass])
				$("span.word.selected").each(function(e) {
					annotatedTags[sentenceIndex][$(this).index()] = entity_classes[tagClass];//tagClass - 1;
				});

				
				if(moveAfterwards) {
					$(".word").removeClass("selected");
					moveForwards();
				}
			}

			// Highlights the currently selected word(s). 
			// 'direction' can be either 'forwards' or 'backwards'. 
			function highlightSelected(direction) {
				var arr = $('span.word.selected');
				console.log(arr.length)
				if(!chaining) {								
					$(".word").removeClass("selected");
					chainStart = -1;
				} else {		
					var last = $(arr[arr.length]);
					var first = $(arr[0]);

					if(direction == "forwards") {
						if($('span.word.selected').length == 1) {
							chainStart = wordIndex;
							chainType = "forwards";
						}
						if(chainType == "forwards") {
							if(first.index() < chainStart - 1) {
								first.removeClass("selected");
							}
						} else {
							if(first.index() < chainStart) {
								first.removeClass("selected");
							}												
						}

					} else if (direction == "backwards") {
						if($('span.word.selected').length == 1) {
							chainStart = wordIndex + 1;
							chainType = "backwards";
						}
						if(last.index() >= chainStart && chainType == "forwards") {
							last.removeClass("selected");
						}
					}
				}
				
				var selectedWord = getSelectedWord();
				selectedWord.addClass("selected");
				var oft = selectedWord.offset().top;
				// If the currently selected word is not in view, scroll to it.
				if($(window).height() - (oft - $("body").scrollTop()) < 150 || $("body").scrollTop() - oft > -150) {
					if(currentlyScrolling) {
						$("html, body").scrollTop(oft - 150);
					} else {
						currentlyScrolling = true;
						$("html, body").animate({
							scrollTop: oft - 150
						}, 200, finishedScrolling);
					}
				}
				
				// Refresh the tagging menu 
				var arr = $('span.word.selected');
				var tokens = [];
				arr.each(function() {
					tokens.push($(this).text());
				})
				
					
					//tokens.push(arr[i]);
				
				refreshTaggingMenu(tokens.join(" "));
			}

			function scrollToSentence() {
				if(currentlyScrolling) {
					$("html, body").scrollTop(st.children().eq(sentenceIndex).offset().top - 150)
				} else {
					currentlyScrolling = true
					$("html, body").animate({
						scrollTop: st.children().eq(sentenceIndex).offset().top - 150
					}, 200, finishedScrolling);
				}
			}

			// Jumps to the sentence with the index of sentenceIndex.
			function gotoSentence(preventScroll) {

				$(".sentence").removeClass("selected");
				st.children().eq(sentenceIndex).addClass("selected");
				//$("#sentence-number").html(sentenceIndex + 1);	
				if(!preventScroll) {
					scrollToSentence();
				}													
				sentenceLength = calculateSentenceLength()

			}

			function nextSentence() {
				if(sentenceIndex < groupData.length - 1) {
					sentenceIndex++								
					gotoSentence();					
					wordIndex = 0;
				} else {
					saveDataToFile();
					loadGroup();
				}
			}
			function previousSentence() {
				if(sentenceIndex > 0) {
					sentenceIndex--;
					gotoSentence();			
					//$("#sentence-number").html(sentenceIndex + 1);
					//sentenceLength = calculateSentenceLength();
					wordIndex = sentenceLength - 1;
				}
			}

			function moveForwards() {
				wordIndex++;
				if(wordIndex >= sentenceLength)	nextSentence();
				highlightSelected("forwards");
			}
			function moveBackwards() {
				wordIndex--;
				if(wordIndex < 0 && sentenceIndex > 0) previousSentence();
				if(wordIndex == -1) wordIndex = 0;
				highlightSelected("backwards");
			}

			function deleteTag() {
				var selectedWord = getSelectedWord();
				selectedWord.removeClass(function (index, className) {
					return (className.match (/(^|\s)tag-\S+/g) || []).join(' ');
				});
				selectedWord.removeClass("tag")
				annotatedTags[sentenceIndex][selectedWord.index()] = - 1;
			}		

			// Display the tagging window overlay.
			function refreshTaggingMenu(tokens) {

				// Query Wikipedia for the currently selected tokens.
				function queryWikipedia(next) {

					// Processes the result of a Wikipedia query.
					function getResult(data, next) {
						function stripTags(str) {
							return str.replace(/<\/?[^>]+(>|$)/g, "");
						}
						try {
							//console.log(data);
							var title = data.query.search[0].title;
							var snippet = stripTags(data.query.search[0].snippet);
							var wurl = "https://en.wikipedia.org/wiki/" + data.query.search[0].title.replace(/ /g, '_');
							//console.log(title);
							//console.log(snippet);
							//console.log(wurl);
							return next(title, snippet, wurl);
						} catch(err) {
							console.log("No article found.");
							next();
						}
					}
					$.ajax({
						url: 'http://en.wikipedia.org/w/api.php',
						data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },
						dataType: 'jsonp',
						success: function(data) {
							getResult(data, next);
						}
		            });
				}

				$taggingMenuSearch.val('');
				setTimeout( function () {
					$taggingMenuSearch[0].focus();	
				}, 5)
				

				$taggingMenuMore.removeClass("show");
				//$taggingMenu.addClass("show");


				$taggingMenuTokens.html(tokens);
				$taggingMenuSummary.html('<i class="fa fa-spin fa-cog"></i>&nbsp;&nbsp;Loading...');

				queryWikipediaId++;
				var queryId = queryWikipediaId;
				queryWikipedia(function(title, snippet, wurl) {
					if(queryId != queryWikipediaId) return; // Don't do anything if another query has happened since this one started.
					if(snippet) {
						if(title.toLowerCase() == tokens.toLowerCase()) $taggingMenuSummary.html(snippet + "...");						
						else $taggingMenuSummary.html('<span class="different">[' + title + ']</span> ' + snippet + "...");
						
						$taggingMenuMore.addClass("show");
						$taggingMenuReadMore.attr("href", wurl);
					}
					else $taggingMenuSummary.html("(No Wikipedia entry)");					
					
				});



			}

			// Initialise the mouse events, i.e. selecting tokens to tag them.
			function initMouseEvents() {

				var wordClicked = false;
				var startSentenceIndex = -1;
				$(".sentence span").mousedown(function() { // Whenever a span is clicked, begin the selection process.
					$(".word").removeClass("selected");
					var si = $(this).closest(".sentence").data("ind");
					startSentenceIndex = sentenceIndex;
					if(si != sentenceIndex) {
						sentenceIndex = si;
						gotoSentence(true);
						wordIndex = 0;
					}
					wordClicked = true;
				});
				
				$(document).mouseup(function() {

					if(wordClicked) {
						$(".word").removeClass("selected");
						
						var start = $(window.getSelection().getRangeAt(0).startContainer.parentNode);
						var end =   $(window.getSelection().getRangeAt(0).endContainer.parentNode);

						//console.log(window.getSelection().getRangeAt(0))

						var startIndex = start.data('ind');
						var endIndex = end.data('ind');

						var startSentenceIndex = start.parent().data('ind');	// The starting sentence 
						var endSentenceIndex = end.parent().data('ind');		// The ending sentence

						// Some code to ensure the correct part of the sentence is selected when selecting multiple sentences at the same time.
						// Only one sentence can be selected at a time (the one initially clicked).
						var csi = -1;
						if(startSentenceIndex != sentenceIndex) csi = startSentenceIndex;
						if(endSentenceIndex != sentenceIndex) csi = endSentenceIndex;
						if(csi >= 0) {
							if(sentenceIndex < csi) endIndex = calculateSentenceLength();
					   		else if(sentenceIndex > csi) startIndex = 0;
					    }

						wordIndex = endIndex;
						
						// Add the 'selected' class to all selected words.
						var qt = [];
						for(var i = startIndex; i <= endIndex; i++) {						
							var sw = st.children().eq(sentenceIndex).children().eq(i);
							console.log(sw);
							sw.addClass("selected");
							qt.push(sw.text());
						}
						qt = qt.join(" ");

						refreshTaggingMenu(qt);

						document.getSelection().removeAllRanges();	// Deselect all text afterwards.
						//currentlyScrolling = true;
						scrollToSentence();
						//currentlyScrolling = false;
					}
					wordClicked = false;

					
				})



			}	
			
			(function initKeyEvents() {

				const
				LEFT_ARROW = 37,
				UP_ARROW = 38,
				RIGHT_ARROW = 39,
				DOWN_ARROW = 40,
				ONE = 49,
				NINE = 57,
				SHIFT = 16,
				DELETE = 46,
				BACKSPACE = 8,
				ESCAPE = 27;
				
				var map = { 37: false, 39: false, 16: false };
				$(document).keydown(function(e) {
					if(!loading && !ended) {
						if (e.keyCode in map) {
							if(e.keyCode == SHIFT) {
								chaining = true;
							}
							map[e.keyCode] = true;
							if (map[LEFT_ARROW]) {
								chaining = map[SHIFT];			
								moveBackwards();
							} else if (map[RIGHT_ARROW]) {
								chaining = map[SHIFT];
								moveForwards();
							}
						}
						if(e.keyCode >= ONE && e.keyCode <= NINE) {	// Tagging via the arrow keys
							tagSelected(e.keyCode - 48);
						}
						if(e.keyCode == DOWN_ARROW) {								
							nextSentence()
							wordIndex = -1;
							moveForwards()
						}
						if(e.keyCode == UP_ARROW) {
							previousSentence();
							wordIndex = -1;
							moveForwards()
						}
						if(e.keyCode == DELETE) {
							deleteTag();
						}
						//- if(e.keyCode == BACKSPACE) {
						//- 	moveBackwards();
						//- 	deleteTag();
						//- }
						if(e.keyCode == ESCAPE) {
							$entityCategoriesWindow.removeClass("show");
						}
					}					
				}).keyup(function(e) {
					if (e.keyCode in map) {
						map[e.keyCode] = false;
					}
				});
			})();


			// Toggle tagging when clicking elements in the jsTree
			$tree.on('click', '.jstree-anchor', function (e) {		
				var ind = $tree.jstree('get_selected', true)[0].li_attr["data-index"];
				var color = $tree.jstree('get_selected', true)[0].li_attr["data-color"];
				console.log(ind, color);
				tagSelected(ind, color, false);
			});



			// Keypress events
			/*$("body").keydown(function(e) {
					console.log(e)
				if(e.keyCode == 37 || e.keyCode == 65 ) { // left
					console.log("left")
					moveBackwards()
				}
				else if(e.keyCode == 39 || e.keyCode == 68) { // right
					console.log("right")
					moveForwards()
				}
			});*/




			//- function showSavingNotification(filename) {
			//- 	$("#loading-notification").hide()
			//- 	$("#ending-notification").hide()
			//- 	$("#saving-notification").show();
			//- 	$("#saving-filename").html(filename + "...")
			//- 	$("#sentence-counter").hide();
			//- }
			//- function showSentenceCounter() {
			//- 	$("#loading-notification").hide()
			//- 	$("#ending-notification").hide()
			//- 	$("#saving-notification").hide();
			//- 	$("#sentence-counter").show();
			//- }
			//- function showEndingNotification() {
			//- 	$("#loading-notification").hide()
			//- 	$("#ending-notification").show()
			//- 	$("#saving-notification").hide();
			//- 	$("#sentence-counter").hide();						
			//- }


			//- $("#jump-to-batch-go").click(function() {
			//- 	console.log($("#jump-to-batch")[0].value)
			//- 	console.log("clicked")
			//- 	function validateValue(value) {
			//- 		var val = parseInt(value)
			//- 		if(val > 0 && val < groupTotal + 1) {
			//- 				return val
			//- 		} else {
			//- 				return -1
			//- 		}
			//- 	}
			//- 	var v = validateValue($("#jump-to-batch")[0].value)
			//- 	if(v > 0) {
			//- 		groupNumber = v;
			//- 		ended = false
			//- 		loadGroup()
			//- 		$("#jump-to-batch").val("")
			//- 		$("#jump-to-batch").blur()
			//- 	} else {
			//- 		showJumpToGroupError()
			//- 	}
			//- });


			//- function showJumpToGroupError() {
			//- 	function fadeBackOut() {
			//- 		window.setTimeout(function() { $("#jump-to-batch-error").fadeOut(300)}, 1000 )
			//- 	}
			//- 	if($("#jump-to-batch-error:visible").length == 0)
			//- 		$("#jump-to-batch-error").fadeIn(300, fadeBackOut)
			//- }


			function generateAnnotatedTags() {
				for(var i in annotatedTags) {
					for(var j = annotatedTags[i].length - 1; j >= 0; j--) {
						var tag = annotatedTags[i][j];									
						annotatedTags[i][j] = tag != "O" ? "B-" + tag : tag;
						if(j > 0 && tag != "O" && annotatedTags[i][j - 1] == tag) {
							annotatedTags[i][j] = "I-" + tag;
						}
					}
				};
			}

			function saveDataToFileOutput(dataFilename) {
				generateAnnotatedTags();
				outputData = "";
				for(var i = 0; i < groupData.length; i++) {
					for(var j = 0; j < groupData[i].length; j++) {
						outputData += groupData[i][j] + " " + annotatedTags[i][j] + "\n";
					}
					outputData += "\n";
				}

				var dlfile = document.createElement('a');
				dlfile.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(outputData));
				dlfile.setAttribute('download', dataFilename);
				var event = document.createEvent('MouseEvents');
				event.initEvent('click', true, true);
				dlfile.dispatchEvent(event);
			}

			function saveDataToFileSuppressNotification() {
				var dataFilename = "annotated_data_" + 1 + ".txt"
				saveDataToFileOutput(dataFilename)
			}

			function saveDataToFile() {
				var dataFilename = "annotated_data_" + 1 + ".txt"
				//showSavingNotification(dataFilename)
				saveDataToFileOutput(dataFilename)						
			}

			//- $("#save-to-file").click(saveDataToFileSuppressNotification)
		}
		$(document).ready(initTagging);